[gd_scene load_steps=6 format=3 uid="uid://c81o2vgj67swa"]

[sub_resource type="GDScript" id="GDScript_a3bdt"]
script/source = "extends Node2D
class_name Game1A

# =========================
# 常量与资源
# =========================
enum CARD_TYPE { DAY = 1, MEAL = 2, NIGHT = 3 }

const CARD_TEXTURES := {
	
}

# 轨道参数
@export var lane_y: float = 0.0					# 轨道的Y位置（世界坐标），为0表示使用路径的全局Y
@export var card_width: float = 140.0			# 卡牌宽度（碰撞与摆放间距的依据）
@export var card_height: float = 140.0
@export var move_speed: float = 220.0			# 卡牌自动从右向左移动速度
@export var spawn_interval_range := Vector2(1.2, 2.8)	# 随机生成间隔（秒）
@export var max_cards_on_lane: int = 18			# 轨道最多卡数量，防止过密
@export var drag_push_strength: float = 1.0		# 拖拽推挤强度（>0）
@export var right_margin: float = 200.0			# 从右边最初始生成的偏移
@export var left_despawn_x: float = -600.0		# 离开左侧的X阈值（避免泄露）

# 顺序校验：1->2->3 循环
var expected_next: int = CARD_TYPE.DAY

# 信号：失败
signal game_failed

# 运行时
var spawn_timer := 0.0
var next_spawn_time := 1.5
var rng := RandomNumberGenerator.new()

# 节点引用
@onready var spawn_path: Path2D = $SpawnArea1
@onready var cursor_area: Area2D = $Cursor

# 卡牌容器结构
class Card:
	var node: Node2D
	var type: int
	var drag_offset := Vector2.ZERO
	var is_dragging := false

func _ready() -> void:
	# 随机种子
	rng.randomize()
	# 初始刷一波稀疏卡牌（可选）
	_schedule_next_spawn()
	# Cursor 碰撞检测
	if is_instance_valid(cursor_area):
		cursor_area.body_entered.connect(_on_body_entered_cursor)
		cursor_area.area_entered.connect(_on_area_entered_cursor)

func _process(delta: float) -> void:
	# 自动生成
	_handle_spawning(delta)
	# 自动移动
	_auto_move_cards(delta)
	# 排斥重叠（保持不重叠）
	_resolve_overlaps()
	# 清理离场
	_despawn_outside()

# =========================
# 生成与布局
# =========================
func _handle_spawning(delta: float) -> void:
	spawn_timer += delta
	if spawn_timer >= next_spawn_time:
		spawn_timer = 0.0
		_schedule_next_spawn()
		if get_card_count() < max_cards_on_lane:
			_try_spawn_card()

func _schedule_next_spawn() -> void:
	next_spawn_time = rng.randf_range(spawn_interval_range.x, spawn_interval_range.y)

func _try_spawn_card() -> void:
	# 随机是否生成（不是每次都生成）
	var should_spawn := rng.randf() > 0.35
	if not should_spawn:
		return

	# 随机类型
	var r := rng.randi_range(1, 3)
	var ctype: int = r

	var sprite := Sprite2D.new()
	sprite.texture = CARD_TEXTURES.get(ctype, null)
	sprite.centered = true
	sprite.name = \"CardSprite\"

	# 添加可拖拽区域（碰撞用于拖拽命中）
	var area := Area2D.new()
	var shape := CollisionShape2D.new()
	var rect_shape := RectangleShape2D.new()
	rect_shape.size = Vector2(card_width, card_height)
	shape.shape = rect_shape
	area.add_child(shape)

	# 容器节点
	var holder := Node2D.new()
	holder.name = \"Card\"
	holder.add_child(sprite)
	holder.add_child(area)
	add_child(holder)

	# 放到右边起点（Path2D 直线：从右到左）
	var y_on_lane := lane_y != 0.0 ? lane_y : (spawn_path.global_position.y)
	var start_x := get_viewport_rect().size.x + right_margin
	holder.global_position = Vector2(start_x, y_on_lane + rng.randf_range(-6.0, 6.0))

	# 保存类型信息
	holder.set_meta(\"card_type\", ctype)
	# 输入事件绑定（拖拽）
	area.input_event.connect(func(_vp, event, _shape_idx):
		_on_card_input(holder, event)
	)

func get_card_nodes() -> Array:
	var arr: Array = []
	for c in get_children():
		if c is Node2D and c.name == \"Card\":
			arr.append(c)
	return arr

func get_card_count() -> int:
	return get_card_nodes().size()

# =========================
# 拖拽与推挤
# =========================
func _on_card_input(card: Node2D, event: InputEvent) -> void:
	if event is InputEventMouseButton:
		var mb := event as InputEventMouseButton
		if mb.button_index == MOUSE_BUTTON_LEFT:
			if mb.pressed:
				card.set_meta(\"dragging\", true)
				card.set_meta(\"drag_offset_x\", card.global_position.x - get_global_mouse_position().x)
			else:
				card.set_meta(\"dragging\", false)
	elif event is InputEventMouseMotion:
		if card.get_meta(\"dragging\", false):
			var target_x := get_global_mouse_position().x + float(card.get_meta(\"drag_offset_x\", 0.0))
			# 限制在轨道内（仅左右移动）
			var y_on_lane := lane_y != 0.0 ? lane_y : (spawn_path.global_position.y)
			card.global_position = Vector2(target_x, y_on_lane)
			# 推挤：如果发生重叠，向右侧平移相邻卡
			_push_away_right(card)

func _push_away_right(card: Node2D) -> void:
	var cards := get_card_nodes()
	# 依据X排序
	cards.sort_custom(func(a, b): return a.global_position.x < b.global_position.x)
	# 找到当前卡的索引
	var idx := cards.find(card)
	if idx == -1:
		return
	# 向右推挤：只处理右侧的卡
	var current_right := card.global_position.x + card_width * 0.5
	for i in range(idx + 1, cards.size()):
		var other: Node2D = cards[i]
		var desired_left := current_right + 2.0
		var other_left := other.global_position.x - card_width * 0.5
		if other_left < desired_left:
			var delta_x := (desired_left - other_left) * max(drag_push_strength, 0.1)
			other.global_position.x += delta_x
		current_right = other.global_position.x + card_width * 0.5

# =========================
# 自动移动与不重叠
# =========================
func _auto_move_cards(delta: float) -> void:
	var cards := get_card_nodes()
	for c in cards:
		if c.get_meta(\"dragging\", false):
			continue
		c.global_position.x -= move_speed * delta

func _resolve_overlaps() -> void:
	var cards := get_card_nodes()
	# 依据X排序，左->右
	cards.sort_custom(func(a, b): return a.global_position.x < b.global_position.x)
	for i in range(cards.size() - 1):
		var left: Node2D = cards[i]
		var right: Node2D = cards[i + 1]
		var gap := (right.global_position.x - left.global_position.x) - card_width
		# 如果重叠或过近，分离到刚好不重叠
		if gap < 2.0:
			var push := (2.0 - gap) * 0.5
			left.global_position.x -= push
			right.global_position.x += push

func _despawn_outside() -> void:
	var cards := get_card_nodes()
	for c in cards:
		if c.global_position.x < left_despawn_x:
			c.queue_free()

# =========================
# Cursor 顺序校验
# =========================
func _on_body_entered_cursor(_body: Node) -> void:
	# 兼容 body_entered（万一拖拽区域是Body类型）
	pass

func _on_area_entered_cursor(area: Area2D) -> void:
	# 拿到卡牌节点
	var card := area.get_parent()
	if not (card is Node2D) or card.name != \"Card\":
		return
	var ctype := int(card.get_meta(\"card_type\", 0))
	if ctype == 0:
		return
	# 校验 1 -> 2 -> 3 -> 1 循环
	if ctype != expected_next:
		emit_signal(\"game_failed\")
		# 可在此暂停或重置
		return
	# 正确则推进期望
	expected_next = _next_expected(expected_next)
	# 命中后可以删除该卡，模拟被“消费”
	card.queue_free()

func _next_expected(now: int) -> int:
	match now:
		CARD_TYPE.DAY:
			return CARD_TYPE.MEAL
		CARD_TYPE.MEAL:
			return CARD_TYPE.NIGHT
		_:
			return CARD_TYPE.DAY
"

[sub_resource type="Curve2D" id="Curve2D_4rt0p"]
_data = {
"points": PackedVector2Array(0, 0, 0, 0, 2027, 614, 0, 0, 0, 0, -124, 614)
}
point_count = 2

[sub_resource type="RectangleShape2D" id="RectangleShape2D_b0e3b"]
size = Vector2(41.5677, 15.7248955)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_6jrx4"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_4rt0p"]

[node name="game_1a" type="Node2D"]
script = SubResource("GDScript_a3bdt")

[node name="SpawnArea1" type="Path2D" parent="."]
curve = SubResource("Curve2D_4rt0p")

[node name="PathFollow2D" type="PathFollow2D" parent="SpawnArea1"]
position = Vector2(2027, 614)
rotation = 3.1415927

[node name="SpawnArea2" type="Area2D" parent="."]

[node name="CollisionShape2D" type="CollisionShape2D" parent="SpawnArea2"]
position = Vector2(1362.1235, 890.99994)
scale = Vector2(82.750626, 20.26238)
shape = SubResource("RectangleShape2D_b0e3b")

[node name="Cursor" type="Area2D" parent="."]

[node name="CollisionShape2D" type="CollisionShape2D" parent="Cursor"]
position = Vector2(268.99997, 251.99998)
scale = Vector2(-2.3793457, 102.19152)
shape = SubResource("RectangleShape2D_6jrx4")

[node name="DisplayArea" type="Area2D" parent="."]

[node name="CollisionShape2D" type="CollisionShape2D" parent="DisplayArea"]
position = Vector2(903, 253.00003)
scale = Vector2(31.599016, 20.612104)
shape = SubResource("RectangleShape2D_4rt0p")
